[{"content":"System Design Basic 2 SQL vs NoSQL SQL (Relational Databases) Key Examples: MySQL, PostgreSQL, Oracle Core Philosophy: Structured, Strong Consistency, and Transactions When to choose: Fixed \u0026amp; Complex Data Schema:\nE-commerce Orders: Requires Strong Consistency (ACID Transactions):\nNoSQL (Non-Relational Databases) Key Examples: MongoDB (Document), Redis (Key-Value), Cassandra (Columnar) Core Philosophy: High Scalability, Flexibility, and Performanceï¼Œusually accepts Eventual Consistency When to choose: Flexible or Evolving Data Schema:\nNeeds Extremely High Read/Write Throughput \u0026amp; Massive Data Storage:\nRequires High Availability (Fault Tolerance) \u0026amp; Distributed Nature:\nEventual Consistency is Acceptable:\n","date":"2025-05-26T20:51:24+08:00","permalink":"https://sususu5.github.io/p/system-design-basic-2/","title":"System Design Basic 2"},{"content":"System Design Basic 1 CAP Theorem Any distributed system cannot simultaneously guarantee all three of the following properties:\nConsistency\nAll nodes see the same data at the same time All replicas in the system remain synchronized Availability\nThe system remains operational even when some nodes fail Every request receives a response (whether success or failure) Partition Tolerance\nThe system continues to operate despite network partitions (communication breakdowns between nodes) The system functions normally even when messages are lost or delayed Consistency Models Strong Consistency Models\nLinearizability: The strongest consistency guarantee, where the system behaves as if there\u0026rsquo;s only one copy of data, with all operations having a global execution order.\nProvides real-time guarantees Highest performance overhead Use Cases: Financial transaction systems, inventory management Sequential Consistency: All processes see the same order of operations, but it doesn\u0026rsquo;t need to correspond to real-time ordering.\nSlightly weaker than linearizability but more efficient Guarantees consistent global operation ordering Allows some latency Causal Consistency: Only guarantees that causally related operations execute in the same order across all nodes.\nWeaker than sequential consistency but more practical Allows different ordering of concurrent operations Maintains logical dependencies Weak Consistency Models\nEventual Consistency: The system guarantees that all replicas will eventually converge to the same state when no new updates occur.\nHigh availability and performance Allows temporary inconsistencies Requires conflict resolution mechanisms Use Cases: DNS systems, social media feeds, shopping carts Session Consistency: Guarantees consistency within a single session, ensuring users see monotonic data within their session.\nRead-your-writes: Users can see their own writes Monotonic reads: Won\u0026rsquo;t read older data Monotonic writes: Write operations execute in order Partition Tolerance Implementation Strategies\nData Replication: Maintaining copies across multiple nodes Sharding: Distributing data across different nodes Correctness Protocols: Using Paxos, Raft for consistency Failure Detection: Promptly identifying partition issues Recovery Mechanisms\nAnti-entropy: Data synchronization after partition healing Read Repair: Fixing inconsistencies during reads Design Patterns\nLeader Election: Re-establishing primary nodes after partition Read/Write Quorums: Setting R + W \u0026gt; N for consistency ","date":"2025-05-23T21:35:58+08:00","permalink":"https://sususu5.github.io/p/system-design-basic-1/","title":"System Design Basic 1"}]